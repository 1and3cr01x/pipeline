{
  "paragraphs": [
    {
      "text": "%pyspark\n\n# Databricks notebook source exported at Tue, 27 Oct 2015 09:41:59 UTC\n# MAGIC %md\n# MAGIC # **Analytics Example -- Gradient Descent**\n# MAGIC \n# MAGIC In this exercise you will develop a distributed gradient descent algorithm for linear regression.  This exercise uses a subset of the [Million Song Dataset](http://labrosa.ee.columbia.edu/millionsong/) from the [UCI Machine Learning Repository](https://archive.ics.uci.edu/ml/datasets/YearPredictionMSD). Our goal is to train a linear regression model to predict the release year of a song given a set of audio features.\n# MAGIC  \n# MAGIC \n# MAGIC Note that, for reference, you can look up the details of the relevant Spark methods in [Spark\u0027s Python API](https://spark.apache.org/docs/latest/api/python/pyspark.html#pyspark.RDD) and the relevant NumPy methods in the [NumPy Reference](http://docs.scipy.org/doc/numpy/reference/index.html)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC ### ** Part 1: Read and parse the initial dataset **\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC ** (1a) Load and check the data **\n# MAGIC \n# MAGIC The raw data is currently stored in text file.  We will start by storing this raw data as an RDD, with each element of the RDD representing a data point as a comma-delimited string. Each string starts with the label (a year) followed by numerical audio features. Use the [count method](https://spark.apache.org/docs/latest/api/python/pyspark.html#pyspark.RDD.count) to check how many data points we have.  Then use the [take method](https://spark.apache.org/docs/latest/api/python/pyspark.html#pyspark.RDD.take) to create and print out a list of the first 5 data points in their initial string format.\n\n# COMMAND ----------\n\n# load testing library\nfrom test_helper import Test\nimport os.path\nbaseDir \u003d os.path.join(\u0027mnt\u0027, \u0027spark-mooc\u0027)\ninputPath \u003d os.path.join(\u0027cs190\u0027, \u0027millionsong.txt\u0027)\nfileName \u003d os.path.join(baseDir, inputPath)\n\nnumPartitions \u003d 2\nrawData \u003d sc.textFile(fileName, numPartitions)\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\nnumPoints \u003d \u003cFILL IN\u003e\nprint numPoints\nsamplePoints \u003d \u003cFILL IN\u003e\nprint samplePoints\n\n# COMMAND ----------\n\n# TEST Load and check the data (1a)\nTest.assertEquals(numPoints, 6724, \u0027incorrect value for numPoints\u0027)\nTest.assertEquals(len(samplePoints), 5, \u0027incorrect length for samplePoints\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC ** (1b) Using `LabeledPoint` **\n# MAGIC \n# MAGIC In MLlib, labeled training instances are stored using the [LabeledPoint](https://spark.apache.org/docs/latest/api/python/pyspark.mllib.html#pyspark.mllib.regression.LabeledPoint) object.  Write the parsePoint function that takes as input a raw data point, parses it using Python\u0027s [unicode.split](https://docs.python.org/2/library/string.html#string.split) method, and returns a `LabeledPoint`.  Use this function to parse samplePoints (from the previous question).  Then print out the features and label for the first training point, using the `LabeledPoint.features` and `LabeledPoint.label` attributes. Finally, calculate the number features for this dataset.\n# MAGIC \n# MAGIC Note that `split()` can be called directly on a `unicode` or `str` object.  For example, `u\u0027split,me\u0027.split(\u0027,\u0027)` returns `[u\u0027split\u0027, u\u0027me\u0027]`.\n\n# COMMAND ----------\n\nfrom pyspark.mllib.regression import LabeledPoint\nimport numpy as np\n\n# Here is a sample raw data point:\n# \u00272001.0,0.884,0.610,0.600,0.474,0.247,0.357,0.344,0.33,0.600,0.425,0.60,0.419\u0027\n# In this raw data point, 2001.0 is the label, and the remaining values are features\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\ndef parsePoint(line):\n    \"\"\"Converts a comma separated unicode string into a `LabeledPoint`.\n\n    Args:\n        line (unicode): Comma separated unicode string where the first element is the label and the\n            remaining elements are features.\n\n    Returns:\n        LabeledPoint: The line is converted into a `LabeledPoint`, which consists of a label and\n            features.\n    \"\"\"\n    \u003cFILL IN\u003e\n\nparsedSamplePoints \u003d \u003cFILL IN\u003e\nfirstPointFeatures \u003d \u003cFILL IN\u003e\nfirstPointLabel \u003d \u003cFILL IN\u003e\nprint firstPointFeatures, firstPointLabel\n\nd \u003d len(firstPointFeatures)\nprint d\n\n# COMMAND ----------\n\n# TEST Using LabeledPoint (1b)\nTest.assertTrue(isinstance(firstPointLabel, float), \u0027label must be a float\u0027)\nexpectedX0 \u003d [0.8841,0.6105,0.6005,0.4747,0.2472,0.3573,0.3441,0.3396,0.6009,0.4257,0.6049,0.4192]\nTest.assertTrue(np.allclose(expectedX0, firstPointFeatures, 1e-4, 1e-4),\n                \u0027incorrect features for firstPointFeatures\u0027)\nTest.assertTrue(np.allclose(2001.0, firstPointLabel), \u0027incorrect label for firstPointLabel\u0027)\nTest.assertTrue(d \u003d\u003d 12, \u0027incorrect number of features\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC **Visualization 1: Features**\n# MAGIC \n# MAGIC First we will load and setup the visualization library.  Then we will look at the raw features for 50 data points by generating a heatmap that visualizes each feature on a grey-scale and shows the variation of each feature across the 50 sample data points.  The features are all between 0 and 1, with values closer to 1 represented via darker shades of grey.\n\n# COMMAND ----------\n\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\n\nsampleMorePoints \u003d rawData.take(50)\n# You can uncomment the line below to see randomly selected features.  These will be randomly\n# selected each time you run the cell.  Note that you should run this cell with the line commented\n# out when answering the lab quiz questions.\n# sampleMorePoints \u003d rawData.takeSample(False, 50)\n\nparsedSampleMorePoints \u003d map(parsePoint, sampleMorePoints)\ndataValues \u003d map(lambda lp: lp.features.toArray(), parsedSampleMorePoints)\n\ndef preparePlot(xticks, yticks, figsize\u003d(10.5, 6), hideLabels\u003dFalse, gridColor\u003d\u0027#999999\u0027,\n                gridWidth\u003d1.0):\n    \"\"\"Template for generating the plot layout.\"\"\"\n    plt.close()\n    fig, ax \u003d plt.subplots(figsize\u003dfigsize, facecolor\u003d\u0027white\u0027, edgecolor\u003d\u0027white\u0027)\n    ax.axes.tick_params(labelcolor\u003d\u0027#999999\u0027, labelsize\u003d\u002710\u0027)\n    for axis, ticks in [(ax.get_xaxis(), xticks), (ax.get_yaxis(), yticks)]:\n        axis.set_ticks_position(\u0027none\u0027)\n        axis.set_ticks(ticks)\n        axis.label.set_color(\u0027#999999\u0027)\n        if hideLabels: axis.set_ticklabels([])\n    plt.grid(color\u003dgridColor, linewidth\u003dgridWidth, linestyle\u003d\u0027-\u0027)\n    map(lambda position: ax.spines[position].set_visible(False), [\u0027bottom\u0027, \u0027top\u0027, \u0027left\u0027, \u0027right\u0027])\n    return fig, ax\n\n# generate layout and plot\nfig, ax \u003d preparePlot(np.arange(.5, 11, 1), np.arange(.5, 49, 1), figsize\u003d(8,7), hideLabels\u003dTrue,\n                      gridColor\u003d\u0027#eeeeee\u0027, gridWidth\u003d1.1)\nimage \u003d plt.imshow(dataValues,interpolation\u003d\u0027nearest\u0027, aspect\u003d\u0027auto\u0027, cmap\u003dcm.Greys)\nfor x, y, s in zip(np.arange(-.125, 12, 1), np.repeat(-.75, 12), [str(x) for x in range(12)]):\n    plt.text(x, y, s, color\u003d\u0027#999999\u0027, size\u003d\u002710\u0027)\nplt.text(4.7, -3, \u0027Feature\u0027, color\u003d\u0027#999999\u0027, size\u003d\u002711\u0027), ax.set_ylabel(\u0027Observation\u0027)\ndisplay(fig) \npass\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC **(1c) Find the range **\n# MAGIC \n# MAGIC Now let\u0027s examine the labels to find the range of song years.  To do this, first parse each element of the `rawData` RDD, and then find the smallest and largest labels.\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\nparsedDataInit \u003d rawData.map(\u003cFILL IN\u003e)\nonlyLabels \u003d parsedDataInit.map(\u003cFILL IN\u003e)\nminYear \u003d \u003cFILL IN\u003e\nmaxYear \u003d \u003cFILL IN\u003e\nprint maxYear, minYear\n\n# COMMAND ----------\n\n# TEST Find the range (1c)\nTest.assertEquals(len(parsedDataInit.take(1)[0].features), 12,\n                  \u0027unexpected number of features in sample point\u0027)\nsumFeatTwo \u003d parsedDataInit.map(lambda lp: lp.features[2]).sum()\nTest.assertTrue(np.allclose(sumFeatTwo, 3158.96224351), \u0027parsedDataInit has unexpected values\u0027)\nyearRange \u003d maxYear - minYear\nTest.assertTrue(yearRange \u003d\u003d 89, \u0027incorrect range for minYear to maxYear\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC **(1d) Shift labels **\n# MAGIC \n# MAGIC As we just saw, the labels are years in the 1900s and 2000s.  In learning problems, it is often natural to shift labels such that they start from zero.  Starting with `parsedDataInit`, create a new RDD consisting of `LabeledPoint` objects in which the labels are shifted such that smallest label equals zero.\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\nparsedData \u003d parsedDataInit.\u003cFILL IN\u003e\n\n# Should be a LabeledPoint\nprint type(parsedData.take(1)[0])\n# View the first point\nprint \u0027\\n{0}\u0027.format(parsedData.take(1))\n\n# COMMAND ----------\n\n# TEST Shift labels (1d)\noldSampleFeatures \u003d parsedDataInit.take(1)[0].features\nnewSampleFeatures \u003d parsedData.take(1)[0].features\nTest.assertTrue(np.allclose(oldSampleFeatures, newSampleFeatures),\n                \u0027new features do not match old features\u0027)\nsumFeatTwo \u003d parsedData.map(lambda lp: lp.features[2]).sum()\nTest.assertTrue(np.allclose(sumFeatTwo, 3158.96224351), \u0027parsedData has unexpected values\u0027)\nminYearNew \u003d parsedData.map(lambda lp: lp.label).min()\nmaxYearNew \u003d parsedData.map(lambda lp: lp.label).max()\nTest.assertTrue(minYearNew \u003d\u003d 0, \u0027incorrect min year in shifted data\u0027)\nTest.assertTrue(maxYearNew \u003d\u003d 89, \u0027incorrect max year in shifted data\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC ** Visualization 2: Shifting labels **\n# MAGIC \n# MAGIC We will look at the labels before and after shifting them.  Both scatter plots below visualize tuples storing i) a label value and ii) the number of training points with this label.  The first scatter plot uses the initial labels, while the second one uses the shifted labels.  Note that the two plots look the same except for the labels on the x-axis.\n\n# COMMAND ----------\n\n# get data for plot\noldData \u003d (parsedDataInit\n           .map(lambda lp: (lp.label, 1))\n           .reduceByKey(lambda x, y: x + y)\n           .collect())\nx, y \u003d zip(*oldData)\n\n# generate layout and plot data\nfig, ax \u003d preparePlot(np.arange(1920, 2050, 20), np.arange(0, 150, 20))\nplt.scatter(x, y, s\u003d14**2, c\u003d\u0027#d6ebf2\u0027, edgecolors\u003d\u0027#8cbfd0\u0027, alpha\u003d0.75)\nax.set_xlabel(\u0027Year\u0027), ax.set_ylabel(\u0027Count\u0027)\ndisplay(fig) \npass\n\n# COMMAND ----------\n\n# get data for plot\nnewData \u003d (parsedData\n           .map(lambda lp: (lp.label, 1))\n           .reduceByKey(lambda x, y: x + y)\n           .collect())\nx, y \u003d zip(*newData)\n\n# generate layout and plot data\nfig, ax \u003d preparePlot(np.arange(0, 120, 20), np.arange(0, 120, 20))\nplt.scatter(x, y, s\u003d14**2, c\u003d\u0027#d6ebf2\u0027, edgecolors\u003d\u0027#8cbfd0\u0027, alpha\u003d0.75)\nax.set_xlabel(\u0027Year (shifted)\u0027), ax.set_ylabel(\u0027Count\u0027)\ndisplay(fig) \npass\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC ** (1e) Training, validation, and test sets **\n# MAGIC \n# MAGIC We\u0027re almost done parsing our dataset, and our final task involves spliting the dataset into training, validation and test sets. Use the [randomSplit method](https://spark.apache.org/docs/latest/api/python/pyspark.html#pyspark.RDD.randomSplit) with the specified weights and seed to create RDDs storing each of these datasets. Next, cache each of these RDDs, as we will be accessing them multiple times in the remainder of this lab. Finally, compute the size of each dataset and verify that the sum of their sizes equals the value computed in Part (1a).\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\nweights \u003d [.8, .1, .1]\nseed \u003d 42\nparsedTrainData, parsedValData, parsedTestData \u003d parsedData.\u003cFILL IN\u003e\nparsedTrainData.\u003cFILL IN\u003e\nparsedValData.\u003cFILL IN\u003e\nparsedTestData.\u003cFILL IN\u003e\nnTrain \u003d parsedTrainData.\u003cFILL IN\u003e\nnVal \u003d parsedValData.\u003cFILL IN\u003e\nnTest \u003d parsedTestData.\u003cFILL IN\u003e\n\nprint nTrain, nVal, nTest, nTrain + nVal + nTest\nprint parsedData.count()\n\n# COMMAND ----------\n\n# TEST Training, validation, and test sets (1e)\nTest.assertEquals(parsedTrainData.getNumPartitions(), numPartitions,\n                  \u0027parsedTrainData has wrong number of partitions\u0027)\nTest.assertEquals(parsedValData.getNumPartitions(), numPartitions,\n                  \u0027parsedValData has wrong number of partitions\u0027)\nTest.assertEquals(parsedTestData.getNumPartitions(), numPartitions,\n                  \u0027parsedTestData has wrong number of partitions\u0027)\nTest.assertEquals(len(parsedTrainData.take(1)[0].features), 12,\n                  \u0027parsedTrainData has wrong number of features\u0027)\nsumFeatTwo \u003d (parsedTrainData\n              .map(lambda lp: lp.features[2])\n              .sum())\nsumFeatThree \u003d (parsedValData\n                .map(lambda lp: lp.features[3])\n                .reduce(lambda x, y: x + y))\nsumFeatFour \u003d (parsedTestData\n               .map(lambda lp: lp.features[4])\n               .reduce(lambda x, y: x + y))\nTest.assertTrue(np.allclose([sumFeatTwo, sumFeatThree, sumFeatFour],\n                            2526.87757656, 297.340394298, 184.235876654),\n                \u0027parsed Train, Val, Test data has unexpected values\u0027)\nTest.assertTrue(nTrain + nVal + nTest \u003d\u003d 6724, \u0027unexpected Train, Val, Test data set size\u0027)\nTest.assertEquals(nTrain, 5371, \u0027unexpected value for nTrain\u0027)\nTest.assertEquals(nVal, 682, \u0027unexpected value for nVal\u0027)\nTest.assertEquals(nTest, 671, \u0027unexpected value for nTest\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC ### ** Part 2: Create and evaluate a baseline model **\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC **(2a) Average label **\n# MAGIC \n# MAGIC A very simple yet natural baseline model is one where we always make the same prediction independent of the given data point, using the average label in the training set as the constant prediction value.  Compute this value, which is the average (shifted) song year for the training set.  Use an appropriate method in the [RDD API](https://spark.apache.org/docs/latest/api/python/pyspark.html#pyspark.RDD).\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\naverageTrainYear \u003d (parsedTrainData\n                    \u003cFILL IN\u003e)\nprint averageTrainYear\n\n# COMMAND ----------\n\n# TEST Average label (2a)\nTest.assertTrue(np.allclose(averageTrainYear, 53.9316700801),\n                \u0027incorrect value for averageTrainYear\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC **(2b) Root mean squared error **\n# MAGIC \n# MAGIC We naturally would like to see how well this naive baseline performs.  We will use root mean squared error ([RMSE](http://en.wikipedia.org/wiki/Root-mean-square_deviation)) for evaluation purposes.  Use [RegressionMetrics](https://spark.apache.org/docs/latest/api/python/pyspark.mllib.html#pyspark.mllib.evaluation.RegressionMetrics) to compute the RMSE of our baseline model.\n# MAGIC  \n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\nfrom pyspark.mllib.evaluation import RegressionMetrics\n\nlabelsAndPreds \u003d sc.parallelize([(3., 1.), (1., 2.), (2., 2.)])\n# RMSE \u003d sqrt[((3-1)^2 + (1-2)^2 + (2-2)^2) / 3] \u003d 1.291\nexampleRMSE \u003d \u003cFILL IN\u003e\nprint exampleRMSE\n\n# COMMAND ----------\n\n# TEST Root mean squared error (2b)\nTest.assertTrue(np.allclose(exampleRMSE, 1.29099444874), \u0027incorrect value for exampleRMSE\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC **(2c) Training, validation and test RMSE **\n# MAGIC \n# MAGIC Now let\u0027s calculate the training, validation and test RMSE of our baseline model. To do this, first create RDDs of (label, prediction) tuples for each dataset, and then use RegressionMetrics to calculate the RMSE. Note that each RMSE can be interpreted as the average prediction error for the given dataset (in terms of number of years).\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\nlabelsAndPredsTrain \u003d parsedTrainData.\u003cFILL IN\u003e\nrmseTrainBase \u003d \u003cFILL IN\u003e\n\nlabelsAndPredsVal \u003d parsedValData.\u003cFILL IN\u003e\nrmseValBase \u003d \u003cFILL IN\u003e\n\nlabelsAndPredsTest \u003d parsedTestData.\u003cFILL IN\u003e\nrmseTestBase \u003d \u003cFILL IN\u003e\n\nprint \u0027Baseline Train RMSE \u003d {0:.3f}\u0027.format(rmseTrainBase)\nprint \u0027Baseline Validation RMSE \u003d {0:.3f}\u0027.format(rmseValBase)\nprint \u0027Baseline Test RMSE \u003d {0:.3f}\u0027.format(rmseTestBase)\n\n\n# COMMAND ----------\n\n# TEST Training, validation and test RMSE (2c)\nTest.assertTrue(np.allclose([rmseTrainBase, rmseValBase, rmseTestBase],\n                            [21.305869, 21.586452, 22.136957]), \u0027incorrect RMSE value\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC ### ** Part 3: Train (via gradient descent) and evaluate a linear regression model **\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC ** (3a) Gradient summand **\n# MAGIC \n# MAGIC Now let\u0027s see if we can do better via linear regression, training a model via gradient descent (we\u0027ll omit the intercept for now). Recall that the gradient descent update for linear regression is: \\\\( \\scriptsize \\mathbf{w}_{i+1} \u003d \\mathbf{w}_i - \\alpha_i \\sum_j (\\mathbf{w}_i^\\top\\mathbf{x}_j  - y_j) \\mathbf{x}_j \\,.\\\\) where \\\\( \\scriptsize i \\\\) is the iteration number of the gradient descent algorithm, and \\\\( \\scriptsize j \\\\) identifies the observation.\n# MAGIC \n# MAGIC First, implement a function that computes the summand for this update, i.e., the summand equals \\\\( \\scriptsize (\\mathbf{w}^\\top \\mathbf{x} - y) \\mathbf{x} \\, ,\\\\) and test out this function on two examples.  Use the `DenseVector` [dot](http://spark.apache.org/docs/latest/api/python/pyspark.mllib.html#pyspark.mllib.linalg.DenseVector.dot) method.\n\n# COMMAND ----------\n\nfrom pyspark.mllib.linalg import DenseVector\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\ndef gradientSummand(weights, lp):\n    \"\"\"Calculates the gradient summand for a given weight and `LabeledPoint`.\n\n    Note:\n        `DenseVector` behaves similarly to a `numpy.ndarray` and they can be used interchangably\n        within this function.  For example, they both implement the `dot` method.\n\n    Args:\n        weights (DenseVector): An array of model weights (betas).\n        lp (LabeledPoint): The `LabeledPoint` for a single observation.\n\n    Returns:\n        DenseVector: An array of values the same length as `weights`.  The gradient summand.\n    \"\"\"\n    \u003cFILL IN\u003e\n\nexampleW \u003d DenseVector([1, 1, 1])\nexampleLP \u003d LabeledPoint(2.0, [3, 1, 4])\n# gradientSummand \u003d (dot([1 1 1], [3 1 4]) - 2) * [3 1 4] \u003d (8 - 2) * [3 1 4] \u003d [18 6 24]\nsummandOne \u003d gradientSummand(exampleW, exampleLP)\nprint summandOne\n\nexampleW \u003d DenseVector([.24, 1.2, -1.4])\nexampleLP \u003d LabeledPoint(3.0, [-1.4, 4.2, 2.1])\nsummandTwo \u003d gradientSummand(exampleW, exampleLP)\nprint summandTwo\n\n# COMMAND ----------\n\n# TEST Gradient summand (3a)\nTest.assertTrue(np.allclose(summandOne, [18., 6., 24.]), \u0027incorrect value for summandOne\u0027)\nTest.assertTrue(np.allclose(summandTwo, [1.7304,-5.1912,-2.5956]), \u0027incorrect value for summandTwo\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC ** (3b) Use weights to make predictions **\n# MAGIC \n# MAGIC Next, implement a `getLabeledPredictions` function that takes in weights and an observation\u0027s `LabeledPoint` and returns a (label, prediction) tuple.  Note that we can predict by computing the dot product between weights and an observation\u0027s features.\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\ndef getLabeledPrediction(weights, observation):\n    \"\"\"Calculates predictions and returns a (label, prediction) tuple.\n\n    Note:\n        The labels should remain unchanged as we\u0027ll use this information to calculate prediction\n        error later.\n\n    Args:\n        weights (np.ndarray): An array with one weight for each features in `trainData`.\n        observation (LabeledPoint): A `LabeledPoint` that contain the correct label and the\n            features for the data point.\n\n    Returns:\n        tuple: A (label, prediction) tuple.  Make sure that label and prediction are floats.\n    \"\"\"\n    # Make sure to cast the prediction to a Python float using float()\n    return \u003cFILL IN\u003e\n\nweights \u003d np.array([1.0, 1.5])\npredictionExample \u003d sc.parallelize([LabeledPoint(2, np.array([1.0, .5])),\n                                    LabeledPoint(1.5, np.array([.5, .5]))])\nlabelsAndPredsExample \u003d predictionExample.map(lambda lp: getLabeledPrediction(weights, lp))\nprint labelsAndPredsExample.collect()\n\n# COMMAND ----------\n\n# TEST Use weights to make predictions (3b)\nTest.assertEquals(labelsAndPredsExample.collect(), [(2.0, 1.75), (1.5, 1.25)],\n                  \u0027incorrect definition for getLabeledPredictions\u0027)\nTest.assertTrue(isinstance(labelsAndPredsExample.first()[0], float),\n                \u0027getLabeledPrediction needs to return a tuple of floats\u0027)\nTest.assertTrue(isinstance(labelsAndPredsExample.first()[1], float),\n                \u0027getLabeledPrediction needs to return a tuple of floats\u0027)\nTest.assertTrue(not isinstance(labelsAndPredsExample.first()[0], np.float64),\n                \u0027getLabeledPrediction needs to return a tuple of floats (not np.float64s)\u0027)\nTest.assertTrue(not isinstance(labelsAndPredsExample.first()[1], np.float64),\n                \u0027getLabeledPrediction needs to return a tuple of floats (not np.float64s)\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC ** (3c) Gradient descent **\n# MAGIC \n# MAGIC Next, implement a gradient descent function for linear regression and test out this function on an example.\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\ndef linregGradientDescent(trainData, numIters):\n    \"\"\"Calculates the weights and error for a linear regression model trained with gradient descent.\n\n    Note:\n        `DenseVector` behaves similarly to a `numpy.ndarray` and they can be used interchangably\n        within this function.  For example, they both implement the `dot` method.\n\n    Args:\n        trainData (RDD of LabeledPoint): The labeled data for use in training the model.\n        numIters (int): The number of iterations of gradient descent to perform.\n\n    Returns:\n        (np.ndarray, np.ndarray): A tuple of (weights, training errors).  Weights will be the\n            final weights (one weight per feature) for the model, and training errors will contain\n            an error (RMSE) for each iteration of the algorithm.\n    \"\"\"\n    # The length of the training data\n    n \u003d trainData.count()\n    # The number of features in the training data\n    d \u003d len(trainData.take(1)[0].features)\n    w \u003d np.zeros(d)\n    alpha \u003d 1.0\n    # We will compute and store the training error after each iteration\n    errorTrain \u003d np.zeros(numIters)\n    for i in range(numIters):\n        # Use getLabeledPrediction from (3b) with trainData to obtain an RDD of (label, prediction)\n        # tuples.  Note that the weights all equal 0 for the first iteration, so the predictions will\n        # have large errors to start.\n        labelsAndPredsTrain \u003d trainData.\u003cFILL IN\u003e\n        errorTrain[i] \u003d RegressionMetrics(labelsAndPredsTrain).rootMeanSquaredError\n\n        # Calculate the `gradient`.  Make use of the `gradientSummand` function you wrote in (3a).\n        # Note that `gradient` should be a `DenseVector` of length `d`.\n        gradient \u003d \u003cFILL IN\u003e\n\n        # Update the weights\n        alpha_i \u003d alpha / (n * np.sqrt(i+1))\n        w -\u003d \u003cFILL IN\u003e\n    return w, errorTrain\n\n# create a toy dataset with n \u003d 10, d \u003d 3, and then run 5 iterations of gradient descent\n# note: the resulting model will not be useful; the goal here is to verify that\n# linregGradientDescent is working properly\nexampleN \u003d 10\nexampleD \u003d 3\nexampleData \u003d (sc\n               .parallelize(parsedTrainData.take(exampleN))\n               .map(lambda lp: LabeledPoint(lp.label, lp.features[0:exampleD])))\nprint exampleData.take(2)\nexampleNumIters \u003d 5\nexampleWeights, exampleErrorTrain \u003d linregGradientDescent(exampleData, exampleNumIters)\nprint exampleWeights\n\n# COMMAND ----------\n\n# TEST Gradient descent (3c)\nexpectedOutput \u003d [48.88110449,  36.01144093, 30.25350092]\nTest.assertTrue(np.allclose(exampleWeights, expectedOutput), \u0027value of exampleWeights is incorrect\u0027)\nexpectedError \u003d [79.72013547, 30.27835699,  9.27842641,  9.20967856,  9.19446483]\nTest.assertTrue(np.allclose(exampleErrorTrain, expectedError),\n                \u0027value of exampleErrorTrain is incorrect\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC ** (3d) Train the model **\n# MAGIC \n# MAGIC Now let\u0027s train a linear regression model on all of our training data and evaluate its accuracy on the validation set.  Note that the test set will not be used here.  If we evaluated the model on the test set, we would bias our final results.\n# MAGIC \n# MAGIC We\u0027ve already done much of the required work: we computed the number of features in Part (1b); we created the training and validation datasets and computed their sizes in Part (1e); and, we wrote a function to compute RMSE in Part (2b).\n\n# COMMAND ----------\n\n# TODO: Replace \u003cFILL IN\u003e with appropriate code\nnumIters \u003d 50\nweightsLR0, errorTrainLR0 \u003d linregGradientDescent(\u003cFILL IN\u003e)\n\nlabelsAndPreds \u003d parsedValData.\u003cFILL IN\u003e\nrmseValLR0 \u003d RegressionMetrics(labelsAndPreds).rootMeanSquaredError\n\nprint \u0027Validation RMSE:\\n\\tBaseline \u003d {0:.3f}\\n\\tLR0 \u003d {1:.3f}\u0027.format(rmseValBase,\n                                                                       rmseValLR0)\n\n# COMMAND ----------\n\n# TEST Train the model (3d)\nexpectedOutput \u003d [22.64535883, 20.064699, -0.05341901, 8.2931319, 5.79155768, -4.51008084,\n                  15.23075467, 3.8465554, 9.91992022, 5.97465933, 11.36849033, 3.86452361]\nTest.assertTrue(np.allclose(weightsLR0, expectedOutput), \u0027incorrect value for weightsLR0\u0027)\n\n# COMMAND ----------\n\n# MAGIC %md\n# MAGIC \n# MAGIC ** Visualization 3: Training error **\n# MAGIC \n# MAGIC We will look at the log of the training error as a function of iteration. The first scatter plot visualizes the logarithm of the training error for all 50 iterations.  The second plot shows the training error itself, focusing on the final 44 iterations.\n\n# COMMAND ----------\n\nfrom matplotlib.colors import ListedColormap, Normalize\nfrom matplotlib.cm import get_cmap\ncmap \u003d get_cmap(\u0027YlOrRd\u0027)\nnorm \u003d Normalize()\nclrs \u003d cmap(np.asarray(norm(np.log(errorTrainLR0))))[:,0:3]\n\nfig, ax \u003d preparePlot(np.arange(0, 60, 10), np.arange(2, 6, 1))\nax.set_ylim(2, 6)\nplt.scatter(range(0, numIters), np.log(errorTrainLR0), s\u003d14**2, c\u003dclrs, edgecolors\u003d\u0027#888888\u0027, alpha\u003d0.75)\nax.set_xlabel(\u0027Iteration\u0027), ax.set_ylabel(r\u0027$\\log_e(errorTrainLR0)$\u0027)\ndisplay(fig) \npass\n\n# COMMAND ----------\n\nnorm \u003d Normalize()\nclrs \u003d cmap(np.asarray(norm(errorTrainLR0[6:])))[:,0:3]\n\nfig, ax \u003d preparePlot(np.arange(0, 60, 10), np.arange(17, 22, 1))\nax.set_ylim(17.8, 21.2)\nplt.scatter(range(0, numIters-6), errorTrainLR0[6:], s\u003d14**2, c\u003dclrs, edgecolors\u003d\u0027#888888\u0027, alpha\u003d0.75)\nax.set_xticklabels(map(str, range(6, 66, 10)))\nax.set_xlabel(\u0027Iteration\u0027), ax.set_ylabel(r\u0027Training Error\u0027)\ndisplay(fig) \npass\n\n# COMMAND ----------\n\n\n",
      "dateUpdated": "Oct 28, 2015 6:05:58 PM",
      "config": {
        "colWidth": 12.0,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1446055065840_2115474412",
      "id": "20151028-175745_555428475",
      "result": {
        "code": "ERROR",
        "type": "TEXT",
        "msg": "Traceback (most recent call last):\n  File \"/tmp/zeppelin_pyspark.py\", line 160, in \u003cmodule\u003e\n    compiledCode \u003d compile(final_code, \"\u003cstring\u003e\", \"exec\")\n  File \"\u003cstring\u003e\", line 8\n    numPoints \u003d \u003cFILL IN\u003e\n                ^\nSyntaxError: invalid syntax\n"
      },
      "dateCreated": "Oct 28, 2015 5:57:45 PM",
      "dateStarted": "Oct 28, 2015 6:05:58 PM",
      "dateFinished": "Oct 28, 2015 6:05:58 PM",
      "status": "ERROR",
      "progressUpdateIntervalMs": 500
    },
    {
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "jobName": "paragraph_1446055078566_-1648508753",
      "id": "20151028-175758_714661629",
      "dateCreated": "Oct 28, 2015 5:57:58 PM",
      "status": "READY",
      "progressUpdateIntervalMs": 500
    }
  ],
  "name": "MLlib/07: Gradient Descent",
  "id": "2B4UPWZJ1",
  "angularObjects": {
    "2AR33ZMZJ": [],
    "2AS9P7JSA": [],
    "2ARR8UZDJ": []
  },
  "config": {
    "looknfeel": "default"
  },
  "info": {}
}